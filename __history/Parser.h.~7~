#ifndef _PARSER_H
#define _PARSER_H

#include "translation.h"
#include "index.h"
  #include <sstream>


  double string_to_double( const std::string& s )
 {
   std::istringstream i(s);
   double x;
   if (!(i >> x))
	 return 0;
   return x;
 }


enum state { start, digit, double_digit, word, symbol, error };

string z;
stack <string> number_stack;
stack <string> operation_stack;
stack <string> num;

int const ss = 8; // система сисления
string file_name = "detailed_answer_kr.txt";
int count_point = 0; // счетчик точек
bool toch_flag = false; // флаг для ораничения колиества точек в диапозоне одного числа
char s[100] = ""; // строка, содержащая вводимое выражение
int i = 0;
char tochnost[5] = "";
int t_ind = 0; // индекс строки для точности числа
string p = ""; // для преобразования char to string
    class counter {
public:
	double element;


	void Addition(double el_1, double el_2) { element = el_1 + el_2; } //сложение
	void Subtraction(double el_1, double el_2) { element = el_1 - el_2; } //вычитание
	void Multiplication(double el_1, double el_2) { element = el_1 * el_2; } //умножение
	void Division(double el_1, double el_2) { element = el_1 / el_2; } // деление с остатком
	void DivisionWithoutRemainder(double el_1, double el_2) { element = (int)el_1 / (int)el_2; } // деление без остатка

};

class calculator {
protected:
	string line;
	counter obj;

public:

	//преобразование выражения в опз
	void opz(string operation) {
		if (indexk_op(operation) == 4) { number_stack.push(operation); }
		else if (indexk_op(operation) == 3 || indexk_op(operation) == 2) {
			if (operation_stack.empty() || indexk_op(operation_stack.top()) < 2) {
				operation_stack.push(operation);
			}
			else {

				while (indexk_op(operation_stack.top()) >= indexk_op(operation)) {
					number_stack.push(operation_stack.top());
					operation_stack.pop();
				}
				operation_stack.push(operation);
			}
		}
		else if (indexk_op(operation) == 1) {
			operation_stack.push(operation);
		}
		else if (indexk_op(operation) == 0) {
			while (indexk_op(operation_stack.top()) != 1) {
				number_stack.push(operation_stack.top());
				operation_stack.pop();
			}
			operation_stack.pop();
		}

	}

	//вычисление выражения, записанного в ОПЗ
	void answer(int ss, string file_name, int accuracy) {
		counter obj;
		string s;
		double n1, n2;
		int count_action = 1; //  номер действия
		while (!num.empty()) {
			if (indexk_op(num.top()) == 4) {
				operation_stack.push(num.top());
				num.pop();
			}
			else {
			 AnsiString d1 = operation_stack.top().c_str();
			  d1.Delete(2,1);
			double ch1 = string_to_double(d1.c_str());
			n2 = translation_10(ch1,ss, accuracy, file_name);
			operation_stack.pop();
					AnsiString d2 = operation_stack.top().c_str();
				 d2.Delete(2,1);
				 double ch2 = string_to_double(d2.c_str());
				n1 = translation_10(ch2, ss, accuracy, file_name);
				operation_stack.pop();

				 AnsiString	pr ;
				switch (indexk_op(num.top())) {
				case 2:
					if (num.top() == "+") {
						obj.Addition(n1, n2);

							pr = FloatToStr(translation_file(obj.element, ss, file_name, accuracy)) ;



						ofstream f;
						f.open(file_name.c_str(), ios::app);
						f << '\t' << count_action << ") " << translation_file(n1, ss, file_name, accuracy) << " + " << translation_file(n2, ss, file_name, accuracy) << " = " <<  pr.c_str() << endl;
						f.close();


						count_action++;
					}
					else {
						obj.Subtraction(n1, n2);

							pr = FloatToStr(translation(obj.element, ss, accuracy));


						ofstream f;
						f.open(file_name.c_str(), ios::app);
						f << '\t' << count_action << ") " << translation_file(n1, ss, file_name, accuracy) << " - " << translation_file(n2, ss, file_name, accuracy) << " = " << pr.c_str() << endl;
						f.close();


						//cout << count_action << ' ' << translation(n1, ss,  file_name,  accuracy) << " - " << translation(n2, ss, file_name,  accuracy) << " = " << s << endl;
						count_action++;
					}
					break;
				case 3:

					if (num.top() == "*") {
						obj.Multiplication(n1, n2);
							pr = FloatToStr(translation(obj.element, ss, accuracy));


						ofstream f;
						f.open(file_name.c_str(), ios::app);
						f << '\t' << count_action << ") " << translation_file(n1, ss, file_name, accuracy) << " * " << translation_file(n2, ss, file_name, accuracy) << " = " << pr.c_str() << endl;
						f.close();


						//cout << count_action << ' ' << translation(n1, ss, file_name, accuracy) << " * " << translation(n2, ss, file_name, accuracy) << " = " << s << endl;
						count_action++;
					}
					else if (num.top() == "/") {
						if (n2 == 0) {
							ShowMessage(	"\t\t\tОшибка.\n\t\t\tДеление на 0.\n \t\tНажмите \"OK\" и введите корректное выражение заново.");

						}
						else {

							obj.Division(n1, n2);
								pr = FloatToStr(translation(obj.element, ss, accuracy));



							ofstream f;
							f.open(file_name.c_str(), ios::app);
							f << '\t' << count_action << ") " << translation_file(n1, ss, file_name, accuracy) << " / " << translation_file(n2, ss, file_name, accuracy) << " = " << pr.c_str() << endl;
							f.close();


							//	cout << count_action << ' ' << translation(n1, ss, file_name, accuracy) << " / " << translation(n2, ss, file_name, accuracy) << " = " << s << endl;
							count_action++;
						}
					}
					else if (num.top() == "div") {
						if (n2 == 0) {
							ShowMessage(	"\t\t\tОшибка.\n\t\t\tДеление на 0.\n \t\tНажмите \"OK\" и введите корректное выражение заново.");


						}
						else {
							obj.DivisionWithoutRemainder(n1, n2);
								pr =FloatToStr(translation(obj.element, ss, accuracy));

							ofstream f;
							f.open(file_name.c_str(), ios::app);
							f << '\t' << count_action << ") " << translation_file(n1, ss, file_name, accuracy) << " div " << translation_file(n2, ss, file_name, accuracy) << " = " << pr.c_str()<< endl;
							f.close();

						}
						//	cout << count_action << ' ' << translation(n1, ss, file_name, accuracy) << " div " << translation(n2, ss, file_name, accuracy) << " = " << s << endl;
						count_action++;
					} //целочисленное деление
					break;
				}
				num.pop();
				operation_stack.push(pr.c_str());
			}


		}

	}




};


string parser(string s, int ss, string file_name, int  accuracy) {
	string  sl = "", data = ""; // sl для формаривания слова , data для формирования числа
	int count_bracket = 0;
	state state = start;
	calculator  cl;
	int i = 0; // счетчик в входной строке
			   //int j = 0, l = 0, m = 0;
	char c, next_c; // c текущий символ строки , next_c cледующий
	bool flag = false; // флаг для перехода в состояние "double_digit"

	s = "( " + s + ") ";
	while (i < s.length() - 1) {
		c = s[i];
		next_c = s[i + 1];
		string z = "";
		z = z + c;
		switch (state)
		{
		case start:
			switch (index(c))
			{
			case 1: state = word;
				break;
			case 2: state = digit;
				if (flag) state = double_digit;
				break;
			case 3: state = symbol;
				break;
			case 4: state = start; i++;
				count_point = 0;
				break;
			default: state = error;
				break;

			}
			break;
		case word:
			switch (index(c))
			{
			case 1:
				i++;
				sl = sl + c;
				if (index(next_c) == 4) {
					state = start;
					cl.opz(sl);
					sl = "";
				}
				break;
			default: state = error;
				break;
			}
			break;
		case digit:
			switch (index(c))
			{
			case 2:
				i++;
				data = data + c;
				if (next_c == '.') {
					state = double_digit;
					flag = true;
				}
				if (index(next_c) == 4) {
					state = start;
					cl.opz(data);
					data = "";
					flag = false;
					count_point = 0;
				}

				break;
			default: state = error;
				break;
			}
			break;
		case double_digit:
			i++;
			data = data + c;
			if (index(next_c) == 4) {
				state = start;
				cl.opz(data);
				data = "";
				count_point = 0;
				flag = true;
			}
			break;
		case symbol:
			switch (index(c)) {
			case 3:
				 if (c=='(') { count_bracket +=1;}
				 if (c==')') {count_bracket -=1;}
				if (index(next_c) == 4) { state = start; }
				cl.opz(z);
				i++;

				break;
			default: state = error;
				break;
			}
			break;
		case error:
		ShowMessage("\t\t\tОшибка.\n \t\tНажмите \"OK\" и введите корректное выражение заново.");

			state = start;
			i = s.length();
			break;
		}
	}
	 if (count_bracket!=0) {
			ShowMessage("\t\t\tОшибка.\n Не правильно расставленны скобки. \t\tНажмите \"OK\" и введите корректное выражение заново.");
	 }
	// проверка стека при создании опз (когда строка разобрана)
	if (!operation_stack.empty()) {
		while (operation_stack.empty()) {
			number_stack.push(operation_stack.top());
			operation_stack.pop();
		}
	}
	string print_opz = "";
	//переворачиваем стек
	while (!number_stack.empty()) {
		print_opz = number_stack.top() + ' ' + print_opz;
		num.push(number_stack.top());
		number_stack.pop();
	}
	ofstream f;
	f.open(file_name.c_str(), ios::app);
	f << ' ' + print_opz << endl << " 2.Подсчет выражения : \n";

	f.close();

	cl.answer(ss, file_name, accuracy);

	string ans = operation_stack.top();
	return  ans;

}



#define _CRT_SECURE_NO_WARNINGS
#endif